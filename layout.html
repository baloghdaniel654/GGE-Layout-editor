<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@0.5.0-beta4/dist/html2canvas.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
    crossorigin="anonymous"></script>
  <link rel="icon" type="image/webp" href="./img/favicon.ico">
  <meta charset="UTF-8">
  <title>Castle Layout Editor</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background-color: #f2d9bb;
      color: #433120;
    }

    .navbar {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      background-color: #443326;
      padding: 10px;
      position: fixed;
      left: 0;
      height: 100%;
      max-width: 350px;
      min-width: 350px;

    }

    .builder {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 10px;
      background-color: #775036;
      max-width: 330px;
      min-width: 330px;
      color: #EAD0B2;
      height: 100%;
    }

    .builder label {
      font-weight: bold;
      margin-top: 15px;
    }

    .builder h3 {
      font-size: 26px;
      font-weight: bold;
      color: #F3C24A;
    }

    .slider-container {
      width: 100%;
      display: flex;
      flex-direction: column;
    }

    .slider {
      width: 100%;
      height: 15px;
      border-radius: 5px;
      background: #d3d3d3;
      outline: none;
      opacity: 0.7;
      -webkit-transition: .2s;
      transition: opacity .2s;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
    }

    .container {
      position: relative;
      width: calc(60 * 14.4px);
      height: calc(60 * 14.4px);
      border: 1px solid;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f2d9bb;
      margin-left: 24%;
      padding: 0;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(60, 1fr);

    }

    .cell {
      width: 14.4px;
      height: 14.4px;
      box-sizing: border-box;
      border: 1px solid;
    }

    .building {
      position: absolute;
      user-select: none;
      z-index: 1;
      border: 1px solid black;
    }

    html,
    body,
    .container-fluid,
    .row,
    .col {
      height: 100%;
    }

    img {
      background: none;
      height: 40px;
      width: auto;
    }

    .gridExpand .container {
      width: calc(70 * 14.4px);
      margin-left: 20%;
    }

    .gridExpand .grid {
      grid-template-rows: repeat(1, 1fr);
      grid-template-columns: repeat(70, 1fr);
    }

    button {
      border: none;
      background: none;
    }

    #buildingList {
      overflow-y: auto;
      max-height: 450px;
      width: 300px;
    }
  </style>
</head>

<body>

  <div class="container-fluid asd">
    <div class="row h-100">
      <div class="col-2 p-0">
        <div class="navbar">
          <div class="builder">
            <h3>NEW BUILDING <button onclick="validateAndCreateBuilding()"><img src="./img/create.png" alt="create"
                  title="Create building"></button><button onclick="takeScreenshot()"><img src="./img/screenshot.png"
                  alt="screenshot" title="Screenshot"></button></h3>
            <div class="slider-container">
              <label for="widthInput">WIDTH: <span id="widthValue">5</span></label>
              <input class="slider" type="range" id="widthInput" min="2" max="30" value="5" />

            </div>
            <div class="slider-container">
              <label for="heightInput">HEIGHT: <span id="heightValue">5</span></label>
              <input class="slider" type="range" id="heightInput" min="2" max="30" value="5" />
            </div>
            <label for="colorInput">COLOR (RGB):</label>
            <input class="form-control" type="text" id="colorInput" value="100 100 100" />
            <label for="nameInput">NAME:</label>
            <input class="form-control" type="text" id="nameInput" maxlength="12" />
            <button id="grid-expand-toggle">Castle expansion: OFF</button>
            <button onclick="optimizeBuildings()">
              Optimize Buildings
            </button>
            <h3 class="mt-3">ALL BUILDINGS <button onclick="clearAllBuildings()"><img src="./img/clear.png" alt="clear"
                  title="Clear all buildings"></button></h3>
            <div id="buildingList"></div>
          </div>
        </div>
      </div>
      <div class="col-10 p-0 mt-4">
        <div class="container" onmousemove="moveBuilding(event)" onmouseup="stopMovingBuilding()"
          oncontextmenu="removeBuilding(event)">
          <div class="grid" id="grid"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let buildingCount = 0;
    let buildingData = [];

    const container = document.querySelector('.container');
    const grid = document.getElementById('grid');
    const buildingList = document.getElementById('buildingList');
    let isBuildingMoving = false;
    let startX, startY, currentBuilding;

    function snapToGrid(building) {
      const rect = container.getBoundingClientRect();
      const gridWidth = 14.4;
      const gridHeight = 14.4;

      const nearestX = Math.round(building.offsetLeft / gridWidth) * gridWidth;
      const nearestY = Math.round(building.offsetTop / gridHeight) * gridHeight;

      building.style.left = nearestX + 'px';
      building.style.top = nearestY + 'px';
    }

    function checkBuildingsCollision(currentBuilding) {
      const buildings = document.querySelectorAll('.building');
      buildings.forEach(building => {
        if (building !== currentBuilding && isCollidingWithMargin(currentBuilding, building)) {
          resolveCollision(currentBuilding, building);
        }
      });
    }

    function isCollidingWithMargin(item1, item2) {
      const rect1 = item1.getBoundingClientRect();
      const rect2 = item2.getBoundingClientRect();
      const margin = 2;

      return !(rect1.right - margin < rect2.left + margin ||
        rect1.left + margin > rect2.right - margin ||
        rect1.bottom - margin < rect2.top + margin ||
        rect1.top + margin > rect2.bottom - margin);
    }


    function resolveCollision(item1, item2) {
      const rect1 = item1.getBoundingClientRect();
      const rect2 = item2.getBoundingClientRect();
      const deltaX = rect1.left - rect2.left;
      const deltaY = rect1.top - rect2.top;

      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 0) {
          item1.style.left = rect2.right - container.getBoundingClientRect().left + 'px';
        } else {
          item1.style.left = rect2.left - rect1.width - container.getBoundingClientRect().left + 'px';
        }
      } else {
        if (deltaY > 0) {
          item1.style.top = rect2.bottom - container.getBoundingClientRect().top + 'px';
        } else {
          item1.style.top = rect2.top - rect1.height - container.getBoundingClientRect().top + 'px';
        }
      }
      snapToGrid(item1);
    }

    function isColliding(item1, item2) {
      const rect1 = item1.getBoundingClientRect();
      const rect2 = item2.getBoundingClientRect();
      return !(rect1.right < rect2.left ||
        rect1.left > rect2.right ||
        rect1.bottom < rect2.top ||
        rect1.top > rect2.bottom);
    }

    function validateAndCreateBuilding() {
      const width = parseInt(document.getElementById('widthInput').value);
      const height = parseInt(document.getElementById('heightInput').value);
      if (width < 2 || height < 2) {
        alert('The values ​​must be greater than 2!');
      } else {
        createCustomBuilding();
      }
    }

    function createCustomBuilding() {
      const width = parseInt(document.getElementById('widthInput').value) * 14.4;
      const height = parseInt(document.getElementById('heightInput').value) * 14.4;
      const color = document.getElementById('colorInput').value.split(' ').join(',');
      let name = document.getElementById('nameInput').value;

      if (name.trim() === "") {
        name = "noName";
      }

      if (buildingCount >= 100) {
        alert('A maximum of 100 buildings are allowed at one time.');
        return;
      }

      const newBuilding = document.createElement('div');
      newBuilding.className = 'building custom';
      newBuilding.style.width = width + 'px';
      newBuilding.style.height = height + 'px';
      newBuilding.style.backgroundColor = `rgb(${color})`;
      newBuilding.style.position = 'absolute';
      newBuilding.style.left = Math.random() * (container.getBoundingClientRect().width - width) + 'px';
      newBuilding.style.top = Math.random() * (container.getBoundingClientRect().height - height) + 'px';

      const nameLayer = document.createElement('div');
      nameLayer.style.pointerEvents = 'none';
      nameLayer.innerHTML = `<div style="text-align: center;">${name}</div>`;
      newBuilding.appendChild(nameLayer);

      container.appendChild(newBuilding);

      buildingCount++;

      document.addEventListener('mousemove', moveBuilding);
      document.addEventListener('mouseup', stopMovingBuilding);

      const buildingInfo = document.createElement('div');
      buildingInfo.innerHTML = `${name} - ${width / 14.4}x${height / 14.4} - RGB:${color}`;
      buildingList.appendChild(buildingInfo);

      buildingData.push({ name: name, color: color, width: width, height: height, element: newBuilding, infoElement: buildingInfo });
    }


    function removeBuilding(e) {
      e.preventDefault();
      if (e.target.classList.contains('building')) {
        const removedBuilding = buildingData.find(data => data.element === e.target);
        if (removedBuilding) {
          removedBuilding.infoElement.remove();
          const index = buildingData.indexOf(removedBuilding);
          if (index > -1) {
            buildingData.splice(index, 1);
            buildingCount--;
          }
        }
        e.target.remove();
      }
    }

    function clearAllBuildings() {
      const buildings = document.querySelectorAll('.building');
      buildings.forEach(building => building.remove());
      buildingData.forEach(data => data.infoElement.remove());
      buildingData = [];
      buildingCount = 0;
    }

    function checkIfInGrid(building) {
      const rect = container.getBoundingClientRect();
      if (
        building.offsetLeft < 0 ||
        building.offsetTop < 0 ||
        building.offsetLeft + building.offsetWidth > rect.width ||
        building.offsetTop + building.offsetHeight > rect.height
      ) {
        building.style.left = rect.width / 2 - building.offsetWidth / 2 + 'px';
        building.style.top = rect.height / 2 - building.offsetHeight / 2 + 'px';
      }
    }

    const gridContainer = document.getElementById('grid');

    gridContainer.innerHTML = '';

    const gridSize = 70;
    for (let i = 0; i < gridSize * gridSize; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      gridContainer.appendChild(cell);
    }

    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const widthValue = document.getElementById('widthValue');
    const heightValue = document.getElementById('heightValue');

    widthValue.innerHTML = widthInput.value;
    heightValue.innerHTML = heightInput.value;

    widthInput.oninput = function () {
      widthValue.innerHTML = this.value;
    };

    heightInput.oninput = function () {
      heightValue.innerHTML = this.value;
    };
    function takeScreenshot() {
      html2canvas(document.querySelector('.container')).then(canvas => {
        const dataUrl = canvas.toDataURL();

        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = 'gge-castle-layout-editor.png';

        link.click();
      });
    }

    function startMovingBuilding(e) {
      if (e.type === 'mousedown' || e.type === 'touchstart') {
        isBuildingMoving = true;
        const rect = container.getBoundingClientRect();
        startX = (e.type === 'mousedown') ? e.clientX - rect.left - e.target.offsetLeft : e.touches[0].clientX - rect.left - e.target.offsetLeft;
        startY = (e.type === 'mousedown') ? e.clientY - rect.top - e.target.offsetTop : e.touches[0].clientY - rect.top - e.target.offsetTop;
        currentBuilding = e.target;
      }
    }

    function moveBuilding(e) {
      if (isBuildingMoving) {
        const rect = container.getBoundingClientRect();
        let newX, newY;

        if (e.type === 'mousemove') {
          newX = e.clientX - rect.left - startX;
          newY = e.clientY - rect.top - startY;
        } else if (e.type === 'touchmove') {
          newX = e.touches[0].clientX - rect.left - startX;
          newY = e.touches[0].clientY - rect.top - startY;
        }

        if (newX < 0) newX = 0;
        if (newY < 0) newY = 0;
        if (newX > rect.width - currentBuilding.offsetWidth) newX = rect.width - currentBuilding.offsetWidth;
        if (newY > rect.height - currentBuilding.offsetHeight) newY = rect.height - currentBuilding.offsetHeight;

        currentBuilding.style.left = newX + 'px';
        currentBuilding.style.top = newY + 'px';
        snapToGrid(currentBuilding);
        checkBuildingsCollision(currentBuilding);
        checkIfInGrid(currentBuilding);
      }
    }

    function stopMovingBuilding() {
      if (isBuildingMoving) {
        isBuildingMoving = false;
        snapToGrid(currentBuilding);
        checkBuildingsCollision(currentBuilding);
        checkIfInGrid(currentBuilding);
      }
    }

    document.addEventListener('touchstart', startMovingBuilding);
    document.addEventListener('touchmove', moveBuilding);
    document.addEventListener('touchend', stopMovingBuilding);

    document.addEventListener('mousedown', startMovingBuilding);
    document.addEventListener('mousemove', moveBuilding);
    document.addEventListener('mouseup', stopMovingBuilding);


    const gridExpandToggle = document.getElementById('grid-expand-toggle');
    const body = document.body;
    const isExpand = localStorage.getItem('gridExpand') === 'true';

    if (isExpand) {
      body.classList.add('gridExpand');
      gridExpandToggle.innerHTML = "Castle expansion: ON";
    } else {
      gridExpandToggle.innerHTML = "Castle expansion: OFF";
    }

    gridExpandToggle.addEventListener('click', () => {
      body.classList.toggle('gridExpand');
      const currentMode = body.classList.contains('gridExpand');
      localStorage.setItem('gridExpand', currentMode.toString());

      if (currentMode) {
        gridExpandToggle.innerHTML = "Castle expansion: ON";
      } else {
        gridExpandToggle.innerHTML = "Castle expansion: OFF";
      }
    });
    function optimizeBuildings() {
      const sortedBuildings = buildingData.slice().sort((a, b) => {
        const areaA = a.width * a.height;
        const areaB = b.width * b.height;
        return areaA - areaB;
      });

      const rect = container.getBoundingClientRect();
      let x = 0;
      let y = 0;
      let maxHeight = 0;

      sortedBuildings.forEach(building => {
        if (x + building.width > rect.width) {
          x = 0;
          y += maxHeight;
          maxHeight = 0;
        }

        building.element.style.left = x + 'px';
        building.element.style.top = y + 'px';
        x += building.width;

        if (building.height > maxHeight) {
          maxHeight = building.height;
        }
      });
    }

  </script>

</body>

</html>